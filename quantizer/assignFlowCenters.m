function [flowHist] = assignFlowCenters(flows,flowInd,flowCenters,rawInd,m,n,calcMeth)

% calculate histogram distribution of trajectory identities over centers in
% each time window
% INPUT:
%     flows: generated by function getFlows. Rows indicate
%         trajectories in the given time window, columns indicate time points;
%         the first column indicates the time window of the current
%         trajectory, the second column indicates the patch index, the rest
%         of the columns pairs up to give (dx,dy).
%     flowInd: generated by kmeans clustering. Each entry indicates the
%        cluster identity of the corresponding trajectory in allFlows.
%     calcMeth: method used for calculating histogram
%         - 'hard': direct histogram calculation
%         - 'kcb': kernel codebook encoding
%     rawCenters: centers generated by kmeans clustering. only used if
%         calMeth is 'kcb'
% OUTPUT:
%     centerHist: distribution histogram over the centers generated by
%         clustering


numCenters = size(flowCenters,1);
nt = max(flowInd(:,1)); % number of time windows
ns = m*n; % number of patches
flowHist = zeros(nt,numCenters*m*n);
softnum = ceil(numCenters/20); % number of closest centers to take in the soft calculation method

% treat small flows as zero
flow_sig = std(flows(:));
nz = abs(flows)>flow_sig;
flows = flows(sum(nz,2)~=0,:);
flowInd = flowInd(sum(nz,2)~=0,:);

for i = 1:nt % go over all time windows
   if ~isempty(find(flowInd(:,1)==i,1))
       for j = 1:ns % calculate histogram for spatial each patch in the time window
           patchInd = find(flowInd(:,1)==i&flowInd(:,2)==j);
           if ~isempty(patchInd)
               switch calcMeth
                   case 'hard'
                       flowHist(i,(j-1)*numCenters+1:j*numCenters) = ...
                           histc(rawInd(patchInd,:),1:numCenters)./...
                               sum(histc(rawInd(patchInd,:),1:numCenters));
                           flowHist(i,:) = flowHist(i,:)./sum(flowHist(i,:));
                   case 'kcb_euc'
                       rawCentDist = pdist2(flows(patchInd,:),flowCenters);
                       [rawCentDist,keepInd] = sort(rawCentDist,2,'descend');
                       rawHist = zeros(1,numCenters);
                       for k = 1:size(rawCentDist,1)
                           rawHist(keepInd(k,1:softnum)) = rawHist(keepInd(k,1:softnum))+...
                               ((sum(rawCentDist(k,1:softnum),2)*ones(1,softnum)))...
                               ./rawCentDist(k,1:softnum);
                       end
                       flowHist(i,(j-1)*numCenters+1:j*numCenters) = ...
                           sum(rawHist,1)./sum(rawHist(:));
                   case 'kcb_exp'
                       rawCentDist = exp(pdist2(flows(patchInd,:),flowCenters)/2);
                       [rawCentDist,keepInd] = sort(rawCentDist,2,'descend');
                       rawHist = zeros(1,numCenters);
                       for k = 1:size(rawCentDist,1)
                           rawHist(keepInd(k,1:softnum)) = rawHist(keepInd(k,1:softnum))+...
                               (sum(rawCentDist(k,1:softnum),2)*ones(1,softnum))./rawCentDist(k,1:softnum);
                       end
                       flowHist(i,(j-1)*numCenters+1:j*numCenters) = ...
                           sum(rawHist,1)./sum(rawHist(:));
                   case 'llc'
                       flowHist(i,(j-1)*numCenters+1:j*numCenters) = ...
                           sum(LLC_coding_appr(flowCenters,flows(patchInd,:),softnum),1);
                       flowHist(i,(j-1)*numCenters+1:j*numCenters) = ...
                           flowHist(i,(j-1)*numCenters+1:j*numCenters)./...
                           sum(flowHist(i,(j-1)*numCenters+1:j*numCenters));
                   otherwise
                       error('calculation method invalid');
               end
           end
       end
       
   end
end



end