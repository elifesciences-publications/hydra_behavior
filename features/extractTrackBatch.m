function [trackVelBatch,trackLocBatch] = extractTrackBatch(m,n,tw,movieParam,hydraParam)

% extract track information from spatial-temporal cubes with size a*b and
% time window tw from cvs file generated by trackmate
%
% Input:
%     a: size of cube in x direction
%     b: size of cube in y direciton 
%     tw: time window of the cube
%     movieParam: struct generated by paramAll
%     hydraParam: struct generated by function estimateHydraParam
%
% Output:
%     trackVelBatch: a cell array that contains velocity vectors, 
%         each row represents one time window with cubes in a linearized
%         sequence. The element in each cell is a n*(tw*2+1) matrix, n
%         indicates the number of tracked cells in the cube; the first
%         column is the track ID, and (x,y) comes after the track ID for tw
%         frames.
%     trackLocBatch: a cell array that contains point locations, in the
%         same formate as above.


%% get parameters

% calculate the size of the final result
%dimBatch(1) = ceil(movieParam.imageSize(1)/a);
%dimBatch(2) = ceil(movieParam.imageSize(2)/b);
dimBatch(1) = m;
dimBatch(2) = n;
dimBatch(3) = floor((movieParam.numImages-1)/tw);

a = floor(movieParam.imageSize(1)/(m+1));
b = floor(movieParam.imageSize(2)/(n+1));
a0 = hydraParam.centroid(1)-floor(hydraParam.centroid(1)/a)*a;
b0 = hydraParam.centroid(2)-floor(hydraParam.centroid(2)/b)*b;

% import csv track file and get the number of all cells in all frames
%tracksRaw = csvread(movieParam.filenameTracks);
tracksRaw = dlmread(movieParam.filenameTracks,'\t',1,3);

% sort matrix according to trackID and frame
%[~,indx] = sort(tracksRaw(:,6),'ascend');
%tracksRaw = tracksRaw(indx,:);
%[~,indx] = sort(tracksRaw(:,1),'ascend');
%tracksRaw = tracksRaw(indx,:);

% put all tracks together
tracksAll = cell(movieParam.numImages,1);
for i = 1:movieParam.numImages
    ind = (tracksRaw(:,7)==i-1); % because in the csv file frame starts from 0
    infomat = zeros(sum(ind),3);
    infomat(:,1) = tracksRaw(ind,1); % track ID
    coordCurrent = tracksRaw(ind,3:4);
    % rotate to calibrated coordinate system (animal axis aligned)
    coordNew = (coordCurrent-ones(sum(ind),1)*hydraParam.centroid)*...
        hydraParam.rotmat+ones(sum(ind),1)*hydraParam.centroid;
    infomat(:,2:3) = coordNew; % (x,y) location
    tracksAll{i} = infomat;
    clear infomat
    clear ind
end

clear tracksRaw

%% sort cubes

% initialization, final result will be stored in a cell array
trackVelBatch = cell(dimBatch(3),dimBatch(1)*dimBatch(2));
trackLocBatch = cell(dimBatch(3),dimBatch(1)*dimBatch(2));

indt = 1; % index of time window
count = 1; % counting within the time window
for i = 2:tw*dimBatch(3)+1 % neglect incomplete time window
    
    infomat = tracksAll{i};
    
    % go through all the tracked cells in current frame
    for j = 1:size(infomat,1)
        
        % get current coordinate and id, store them
        coord = infomat(j,2:3);
        id = infomat(j,1);
        
        % determine where it belongs to in the linearized cell array of
        % current time window
        %inds = floor(coord(2)/round(movieParam.imageSize(2)/n))*...
        %    dimBatch(1)+ceil(coord(1)/round(movieParam.imageSize(1)/m)); % index of cube in the current time window
        if coord(1) <= a0
            tmp1 = 1;
        elseif coord(1)>m*a+a0
            tmp1 = dimBatch(1);
        else
            tmp1 = ceil((coord(1)-a0)/a);
        end
        if coord(2) <= b0
            tmp2 = 0;
        elseif coord(2)>n*b+b0
            tmp2 = dimBatch(2)-1;
        else
            tmp2 = floor((coord(2)-b0)/b)*dimBatch(1);
        end
        inds = tmp1+tmp2;
        
        if indt==1&&j==49
            i;
        end
        
        % take out the matrices for modification
        velmat = trackVelBatch{indt,inds};
        locmat = trackLocBatch{indt,inds};
        
        % if previous information unavailable
        if isempty(velmat)
            
            infomatPrev = tracksAll{i-1};
            indPrev = find(infomatPrev(:,1)==infomat(j,1));
                
            % if previous spot exists, calculate velocity
            if ~isempty(indPrev)
                velmat(1,1) = infomat(j,1);
                velmat(1,count*2:count*2+1) = infomat(j,2:3)-infomatPrev(indPrev,2:3);
                locmat(1,1) = infomat(j,1);
                locmat(1,count*2:count*2+1) = infomat(j,2:3);
            else % otherwise ignore this round
                continue;
            end
                
        else
                
            % get index
            indtmp = find(velmat(:,1)==id);
            
            % search for the location in previous frame
            infomatPrev = tracksAll{i-1};
            indPrev = find(infomatPrev(:,1)==infomat(j,1));
            
            if ~isempty(indPrev) % if the cell is tracked
                if ~isempty(indtmp)
                    velmat(indtmp,2*count:2*count+1) = infomat(j,2:3)-infomatPrev(indPrev,2:3); 
                    locmat(indtmp,2*count:2*count+1) = infomat(j,2:3);
                else % otherwise ignore this round
                    velmat(end+1,1) = id;
                    velmat(end,2*count:2*count+1) = infomat(j,2:3)-infomatPrev(indPrev,2:3); 
                    locmat(end+1,1) = id;
                    locmat(end,2*count:2*count+1) = infomat(j,2:3); 
                end
            else
                if ~isempty(indtmp) % fill in zeros for future convinience
                    velmat(indtmp,2*count:2*count+1) = zeros(1,2);
                    locmat(indtmp,2*count:2*count+1) = zeros(1,2);
                else
                    continue;
                end
            end
                
        end
        
        trackVelBatch{indt,inds} = velmat;
        trackLocBatch{indt,inds} = locmat;
        
    end
    
    count = count+1;
    
    if count > tw % this time window is finished
        
        % go through all batches and fill in zeros
        for j = 1:dimBatch(1)*dimBatch(2)
            velmat = trackVelBatch{indt,j};
            locmat = trackLocBatch{indt,j};
            if ~isempty(velmat)
                if size(velmat,2)<2*tw+1
                    velmat(:,end:2*tw+1) = 0;
                    locmat(:,end:2*tw+1) = 0;
                end
                velmat = velmat(:,2:2*tw+1);
                locmat = locmat(:,2:2*tw+1);
                trackVelBatch{indt,j} = velmat;
                trackLocBatch{indt,j} = locmat;
            end
        end
        
        indt = indt+1;
        count = 1;
    end
    
    
end



end