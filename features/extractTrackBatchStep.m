function [trackVelBatch,trackLocBatch] = extractTrackBatchStep(tracksAll,m,n,tw)

% extract track information from spatial-temporal cubes with size a*b and
% time window tw from cvs file generated by trackmate
% normalize by centralizing all points to the centroid of hydra, and divide
% by the length of the hydra
%
% Input:
%     a: size of cube in x direction
%     b: size of cube in y direciton 
%     tw: time window of the cube
%     movieParam: struct generated by paramAll
%     hydraParam: struct generated by function estimateHydraParam
%
% Output:
%     trackVelBatch: a cell array that contains velocity vectors, 
%         each row represents one time window with cubes in a linearized
%         sequence. The element in each cell is a n*(tw*2+1) matrix, n
%         indicates the number of tracked cells in the cube; the first
%         column is the track ID, and (x,y) comes after the track ID for tw
%         frames.
%     trackLocBatch: a cell array that contains point locations, in the
%         same formate as above.


% calculate the size of the final result
numCubes = floor(length(tracksAll)/tw);

% initialization, final result will be stored in a cell array
trackVelBatch = cell(numCubes,m*n);
trackLocBatch = cell(numCubes,m*n);

indt = 1; % index of time window
count = 1; % counting within the time window
for i = 2:tw*numCubes % neglect incomplete time window
    
    infomat = tracksAll{i};
    infomatPrev = tracksAll{i-1};
    
    % go through all the tracked cells in current frame
    for j = 1:size(infomat,1)
        
        indPrev = find(infomatPrev(:,1)==infomat(j,1));
        inds = infomat(j,4);
        
        % take out the matrices for modification        
        velmat = trackVelBatch{indt,inds};
        locmat = trackLocBatch{indt,inds};
        
        if ~isempty(indPrev) % if previous tracking information available
            

            if isempty(velmat)
                velmat(1,1) = infomat(j,1);
                velmat(1,count*2:count*2+1) = infomat(j,2:3)-infomatPrev(indPrev,2:3);
                locmat(1,1) = infomat(j,1);
                locmat(1,count*2:count*2+1) = infomat(j,2:3); 
            else
                
                % get index
                indtmp = find(velmat(:,1)==infomat(j,1));
             
                if ~isempty(indtmp)
                    velmat(indtmp,2*count:2*count+1) = infomat(j,2:3)-infomatPrev(indPrev,2:3); 
                    locmat(indtmp,2*count:2*count+1) = infomat(j,2:3);
                else % otherwise start a new row
                    velmat(end+1,1) = infomat(j,1);
                    velmat(end,2*count:2*count+1) = infomat(j,2:3)-infomatPrev(indPrev,2:3); 
                    locmat(end+1,1) = infomat(j,1);
                    locmat(end,2*count:2*count+1) = infomat(j,2:3); 
                end
            
            end
            
        end
        
        trackVelBatch{indt,inds} = velmat;
        trackLocBatch{indt,inds} = locmat;
        
    end
    
    count = count+1;

    if count > tw % this time window is finished
        
        % go through all batches and fill in zeros
        for j = 1:m*n
            velmat = trackVelBatch{indt,j};
            locmat = trackLocBatch{indt,j};
            if ~isempty(velmat)
                if size(velmat,2)<2*tw+1
                    velmat(:,end:2*tw+1) = 0;
                    locmat(:,end:2*tw+1) = 0;
                end
                velmat = velmat(:,2:2*tw+1);
                locmat = locmat(:,2:2*tw+1);
                trackVelBatch{indt,j} = velmat;
                trackLocBatch{indt,j} = locmat;
            end
        end
        
        indt = indt+1;
        count = 1;
    end
    
    
end

end